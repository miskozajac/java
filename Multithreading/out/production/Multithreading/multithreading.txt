Multithreading je dost ine ako klasicke, mnohe veci sa tam robia inak ako som zvyknútý
1. responzivnost, rychlo odpovede resp reakcie na akciu uzivatela
    -keby je len jedno vlakno poziadavka usera sa bude spracovavat az po vybaveni poziadavky predchadzajuceho usera.
2. zvysenie performance vdaka paralelnemu spustaniu
    -znie mi to ako to iste ako bod 1

Ked zapnem počítať OS je potiahnutý z disku do pamäte. (asi do ram)
Ked zapnem aplikaciu OS zoberie túto apku z harddisku a v pamäti vytvorí inštanciu
    -toto sa volá Process alebo Context
    -každý proces je uplne izolovany od ostatných procesov
    PROCESS OBSAHUJE:
        -nejake metadata napr proces ID
        -files ktore appka potrebuje na citanie a zapisovanie
        -kód - instrukcie programu ktore budu vykonane na CPU
        -data (Heap) ktore appka potrebuje
        -a minimalne jedno vlakno nazyvane Main Thread
            -každe vlákno processu má vyšie spomenute veci spoločné ale má vlastný stack aj instruction pointer
            -každe vlákno vykonava iné instrukcie a ine funkcie
            Thread obsahuje:
                -Stack - miesto v pameti kde su ulozene lokalne premenne a kde sú funkcie vykonávané
                -Insturcion pointer - ukazovatel na dalšiu metódu/instrukciu ktorá sa bude vykonávať

Vlakna sheruju data files a kod, vlastne maju stack a pointer

1.
Nove vlakno sa tvorí takto: Thread vlakno = new Thread();
    -do () sa dáva nejake runnable object, vyzera to takto potom:
    Thread vlakno = new Thread(new Runnable() {
        @Override
        public void run() {

        }
    });

vytvorenie objektu vlakno nestačí, musime ho začať
-vlakno.start()

2. vlakno sa dá vytvoriť aj takto:
vytvorime class ktora extends Thread
-staci v nej len overridnuť run metodu
a potom Thread vlakno = new NewVlakno()